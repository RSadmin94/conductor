
import { pool } from "../db.js";

export async function getReport(req, res) {
  try {
    const { projectId } = req.params;

    // Get project
    const projectResult = await pool.query(
      "SELECT id, state, stage, created_at, updated_at FROM projects WHERE id = $1",
      [projectId]
    );

    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: "Project not found" });
    }

    const project = projectResult.rows[0];

    // Get idea (latest)
    const ideaResult = await pool.query(
      "SELECT content FROM ideas WHERE project_id = $1 ORDER BY created_at DESC LIMIT 1",
      [projectId]
    );
    const idea = ideaResult.rows.length > 0 ? ideaResult.rows[0].content : "No idea found";

    // Get feasibility_analysis_v1 artifact
    const feasibilityArtifactResult = await pool.query(
      "SELECT content FROM artifacts WHERE project_id = $1 AND type = $2 ORDER BY created_at DESC LIMIT 1",
      [projectId, "feasibility_analysis_v1"]
    );

    let feasibilityData = null;
    if (feasibilityArtifactResult.rows.length > 0) {
      try {
        feasibilityData = JSON.parse(feasibilityArtifactResult.rows[0].content);
      } catch (e) {
        console.warn("[Report] Could not parse feasibility artifact");
      }
    }

    // Get execution_plan_v1 artifact
    const planningArtifactResult = await pool.query(
      "SELECT content FROM artifacts WHERE project_id = $1 AND type = $2 ORDER BY created_at DESC LIMIT 1",
      [projectId, "execution_plan_v1"]
    );

    let planningData = null;
    if (planningArtifactResult.rows.length > 0) {
      try {
        planningData = JSON.parse(planningArtifactResult.rows[0].content);
      } catch (e) {
        console.warn("[Report] Could not parse planning artifact");
      }
    }

    // Get run records
    const runsResult = await pool.query(
      "SELECT id, state, started_at, ended_at FROM runs WHERE project_id = $1 ORDER BY started_at DESC",
      [projectId]
    );
    const runs = runsResult.rows || [];

    // Generate comprehensive report
    const report = generateReport(project, idea, feasibilityData, planningData, runs);

    res.setHeader("Content-Type", "text/markdown");
    res.send(report);
  } catch (error) {
    console.error("Error generating report:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}

function generateReport(project, idea, feasibilityData, planningData, runs) {
  const generatedAt = new Date().toISOString();

  let report = `# Project Report

## Header

- **Project ID:** ${project.id}
- **Generated:** ${generatedAt}
- **Status:** ${project.stage}

## Executive Summary

### Your Idea

${idea}

`;

  // Feasibility Assessment Section
  if (feasibilityData) {
    report += generateFeasibilitySection(feasibilityData);
  } else {
    report += `## Feasibility Assessment

**Status:** Not generated yet

Feasibility analysis will be available once the analysis is complete.

`;
  }

  // Execution Plan Section
  if (planningData) {
    report += generatePlanningSection(planningData);
  } else {
    report += `## Execution Plan

**Status:** Not generated yet

Execution plan will be available once planning is complete.

`;
  }

  // Execution Runs Section
  if (runs.length > 0) {
    report += generateRunsSection(runs);
  } else {
    report += `## Execution Runs

No execution runs recorded yet.

`;
  }

  // Footer
  report += `## Footer

Report generated by Conductor MVP at ${generatedAt}.
`;

  return report;
}

function generateFeasibilitySection(feasibilityData) {
  let section = `## Feasibility Assessment

`;

  // Verdict and Confidence
  section += `### Verdict: ${feasibilityData.verdict.toUpperCase()}

**Confidence Score:** ${(feasibilityData.confidence * 100).toFixed(0)}%\n\n`;

  // Summary
  if (feasibilityData.summary) {
    section += `### Summary

${feasibilityData.summary}

`;
  }

  // Key Assumptions
  if (feasibilityData.key_assumptions && feasibilityData.key_assumptions.length > 0) {
    section += `### Key Assumptions

${feasibilityData.key_assumptions.map((a) => `- ${a}`).join("\n")}

`;
  }

  // Risks Table
  if (feasibilityData.risks && feasibilityData.risks.length > 0) {
    section += `### Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|-----------|
`;
    feasibilityData.risks.forEach((risk) => {
      section += `| ${risk.risk} | ${risk.likelihood} | ${risk.impact} | ${risk.mitigation} |\n`;
    });
    section += "\n";
  }

  // Unknowns
  if (feasibilityData.unknowns && feasibilityData.unknowns.length > 0) {
    section += `### Unknowns

${feasibilityData.unknowns.map((u) => `- ${u}`).join("\n")}

`;
  }

  // Recommended Next Steps
  if (feasibilityData.recommended_next_steps && feasibilityData.recommended_next_steps.length > 0) {
    section += `### Recommended Next Steps

${feasibilityData.recommended_next_steps.map((step) => `- ${step}`).join("\n")}

`;
  }

  // Suggested Stack
  if (feasibilityData.suggested_stack) {
    section += `### Suggested Technology Stack

`;
    if (feasibilityData.suggested_stack.frontend && feasibilityData.suggested_stack.frontend.length > 0) {
      section += `**Frontend:** ${feasibilityData.suggested_stack.frontend.join(", ")}\n\n`;
    }
    if (feasibilityData.suggested_stack.backend && feasibilityData.suggested_stack.backend.length > 0) {
      section += `**Backend:** ${feasibilityData.suggested_stack.backend.join(", ")}\n\n`;
    }
    if (feasibilityData.suggested_stack.data && feasibilityData.suggested_stack.data.length > 0) {
      section += `**Data:** ${feasibilityData.suggested_stack.data.join(", ")}\n\n`;
    }
    if (feasibilityData.suggested_stack.ai && feasibilityData.suggested_stack.ai.length > 0) {
      section += `**AI/ML:** ${feasibilityData.suggested_stack.ai.join(", ")}\n\n`;
    }
    if (feasibilityData.suggested_stack.infra && feasibilityData.suggested_stack.infra.length > 0) {
      section += `**Infrastructure:** ${feasibilityData.suggested_stack.infra.join(", ")}\n\n`;
    }
  }

  // Estimates
  if (feasibilityData.estimates) {
    section += `### Project Estimates

- **MVP Timeline:** ${feasibilityData.estimates.mvp_weeks} weeks
- **Recommended Team Size:** ${feasibilityData.estimates.team_size}
- **Cost Band:** ${feasibilityData.estimates.cost_band}

`;
  }

  return section;
}

function generatePlanningSection(planningData) {
  let section = `## Execution Plan

`;

  // Timeline
  if (planningData.timeline_weeks) {
    section += `### Timeline

**Total Duration:** ${planningData.timeline_weeks} weeks

`;
  }

  // Phases
  if (planningData.phases && planningData.phases.length > 0) {
    section += `### Phases

`;
    planningData.phases.forEach((phase, index) => {
      section += `#### ${index + 1}. ${phase.name} (${phase.duration_weeks} weeks)

`;
      if (phase.objectives && phase.objectives.length > 0) {
        section += `**Objectives:**\n${phase.objectives.map((o) => `- ${o}`).join("\n")}\n\n`;
      }
      if (phase.deliverables && phase.deliverables.length > 0) {
        section += `**Deliverables:**\n${phase.deliverables.map((d) => `- ${d}`).join("\n")}\n\n`;
      }
      if (phase.success_criteria && phase.success_criteria.length > 0) {
        section += `**Success Criteria:**\n${phase.success_criteria.map((c) => `- ${c}`).join("\n")}\n\n`;
      }
    });
  }

  // Components
  if (planningData.components && planningData.components.length > 0) {
    section += `### Components

| Component | Purpose | Complexity | Dependencies |
|-----------|---------|-----------|--------------|
`;
    planningData.components.forEach((component) => {
      const deps = Array.isArray(component.dependencies) ? component.dependencies.join(", ") : component.dependencies || "None";
      section += `| ${component.name} | ${component.purpose} | ${component.complexity} | ${deps} |\n`;
    });
    section += "\n";
  }

  // Roles
  if (planningData.roles && planningData.roles.length > 0) {
    section += `### Team Roles

`;
    planningData.roles.forEach((role) => {
      section += `#### ${role.role}

${role.responsibilities.map((r) => `- ${r}`).join("\n")}

`;
    });
  }

  // Milestones
  if (planningData.milestones && planningData.milestones.length > 0) {
    section += `### Milestones

| Milestone | Week | Acceptance Criteria |
|-----------|------|-------------------|
`;
    planningData.milestones.forEach((milestone) => {
      const criteria = Array.isArray(milestone.acceptance_criteria)
        ? milestone.acceptance_criteria.join("; ")
        : milestone.acceptance_criteria || "TBD";
      section += `| ${milestone.milestone} | ${milestone.week} | ${criteria} |\n`;
    });
    section += "\n";
  }

  // Open Questions
  if (planningData.open_questions && planningData.open_questions.length > 0) {
    section += `### Open Questions

${planningData.open_questions.map((q) => `- ${q}`).join("\n")}

`;
  }

  // Immediate Next Actions
  if (planningData.immediate_next_actions && planningData.immediate_next_actions.length > 0) {
    section += `### Immediate Next Actions

${planningData.immediate_next_actions.map((action) => `- ${action}`).join("\n")}

`;
  }

  return section;
}

function generateRunsSection(runs) {
  let section = `## Execution Runs

| Run ID | State | Started | Ended |
|--------|-------|---------|-------|
`;

  runs.forEach((run) => {
    const startedAt = new Date(run.started_at).toLocaleString();
    const endedAt = run.ended_at ? new Date(run.ended_at).toLocaleString() : "In Progress";
    section += `| ${run.id.substring(0, 8)}... | ${run.state} | ${startedAt} | ${endedAt} |\n`;
  });

  section += "\n";
  return section;
}
